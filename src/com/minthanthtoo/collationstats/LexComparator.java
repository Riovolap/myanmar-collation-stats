package com.minthanthtoo.collationstats;

import java.util.Arrays;
import java.util.Comparator;

public class LexComparator
{
	public static class WordComparator implements Comparator<Word>
	{
		SyllableComparator comp=new SyllableComparator();
		@Override
		public int compare(Word arg0, Word arg1)
		{
//:			System.out.println("word:" + arg0 + " vs " + arg1);
			int i;
			for (i = 0; i < arg0.syllables.length; i++)
			{
				if (i >= arg1.syllables.length)
					return 1;// 1st arg has longer length; then goes below
				int r=comp.compare(arg0.syllables[i], arg1.syllables[i]);
//:				System.out.println(r);
				if (r != 0)
					return r;
			}
			if (i < arg1.syllables.length)
				return -1;
			else
			{// i==arg.syllables.length
				if (arg0.syllables[0].letters[0].letterType == Letter.LETTER_TYPE_VOWEL_INDEPENDANT)
					return 1;
				if (arg1.syllables[0].letters[0].letterType == Letter.LETTER_TYPE_VOWEL_INDEPENDANT)
					return -1;
			}
			return 0;
		}
	}

	/**
	 * This Comparator is for sorting of Myanmar syllables.
	 * A standard syllable holds one or more letters in the order:"CMvFT",
	 * and must contain at least a consonant ("C") or myanmar symbol("S").
	 * This comparator scans separate arrays of <code>Letter</code> in the
	 * <code>Syllable</code> class:viz. consonant, medials, finals, vowels, townes,
	 * which are regenerated by <code>Syllable</code> constructor.
	 * Because of these cloned arrays, larger memory will be required,but
	 * these pre-scanned arrays aid this comparator in efficiency and adaptibility.
	 * An important example of adaptibility is the case of the correct order
	 * of 'Myanmar Independent Vowels' and 'Myanmar Symbols'
	 * 
	 *
	 * @author Min Thant Htoo
	 *
	 */
	public static class SyllableComparator implements Comparator<Syllable>
	{
		@Override
		public int compare(Syllable arg0, Syllable arg1)
		{
			boolean e = Arrays.equals(arg0.letters, arg1.letters);
			if (e)
				return 0;

//:			System.out.println(arg0 + " vs " + arg1);
			int r=0;

			//compare consonants:"C"
			if (arg0.consonant.length == 0)// not found
			{
				if (arg1.consonant.length == 0)
				{// not found in both
					// do nothing; continue next comparison
				}
				else
				{// found in 2nd
					return -1;//1st is earlier
				}
			}
			else
			{// found in 1
				if (arg1.consonant.length == 0)
				{// not found in 2nd
					return +1;//1st is later
				}
				else
				{// found in both
					if (arg0.consonant[0].codePoint != arg1.consonant[0].codePoint)
						return (arg0.consonant[0].codePoint - arg1.consonant[0].codePoint);
				}
			}
			//end:compare "M"

//:			System.out.println("M");
			//start:compare medials:"M"
			if (arg0.medials.length == 0)// not found
			{
				if (arg1.medials.length == 0)
				{// not found in both
					// do nothing; continue next comparison
				}
				else
				{// found in 2nd
					return -1;//1st is earlier
				}
			}
			else
			{// found in 1
				if (arg1.medials.length <= 0)
				{// not found in 2nd
					return +1;//1st is later
				}
				else
				{// found in both
					r = compareMedials(arg0.medials, 0, arg0.medials.length, arg1.medials, 0, arg1.medials.length);
//:					System.out.println(r);
					if (r != 0)
						return r;
//:					System.out.println(Letter.toHexString(Arrays.copyOfRange(arg0.letters, startIndex0, endIndex0)));
//:					System.out.println(Letter.toHexString(Arrays.copyOfRange(arg1.letters, startIndex1, endIndex1)));
				}
			}
			//end:compare "M"

			//start: compare Finals:"F"
//:			System.out.println("F");
			// We assume "F" must be composed of one "C"/"V" letter and one "Asat"/"Virama" letter
			if (arg0.finals.length == 0)// not found
			{
				if (arg1.finals.length == 0)
				{// not found in both
					// do nothing; continue next comparison
				}
				else
				{// found in 2nd
					return -1;//1st is earlier
				}
			}
			else
			{// found in 1
				if (arg1.finals.length == 0)
				{// not found in 2nd
					return +1;//1st is later
				}
				else
				{// found in both
					r = compareFinals(arg0.finals, 0, arg0.finals.length, arg1.finals, 0, arg1.finals.length);
//:					System.out.println(r);
					if (r != 0)
						return r;
//:					System.out.println(Letter.toHexString(Arrays.copyOfRange(arg0.letters, startIndex0, endIndex0)));
//:					System.out.println(Letter.toHexString(Arrays.copyOfRange(arg1.letters, startIndex1, endIndex1)));
				}
			}
			//end:compare "F"

			//start: compare vowel:"v"
//:			System.out.println("V" + Arrays.toString(arg0.vowels));
			if (arg0.vowels.length == 0)// not found
			{
				if (arg1.vowels.length == 0)
				{// not found in both
					// do nothing; continue next comparison
				}
				else
				{// found in 2nd
					return -1;//1st is earlier
				}
			}
			else
			{// found in 1
				if (arg1.vowels.length == 0)
				{// not found in 2nd
					return +1;//1st is later
				}
				else
				{// found in both
					r = compareVowels(arg0.vowels, 0, arg0.vowels.length, arg1.vowels, 0, arg1.vowels.length);
//:					System.out.println(r);
					if (r != 0 &&
						(r != Integer.MIN_VALUE && r != Integer.MAX_VALUE))
						return r;

//:					System.out.println(Letter.toHexString(Arrays.copyOfRange(arg0.letters, startIndex0, endIndex0)));
//:					System.out.println(Letter.toHexString(Arrays.copyOfRange(arg1.letters, startIndex1, endIndex1)));
				}
			}
			//end:compare "v"

			//start: compare Tones:"T"
//:			System.out.println("T" + Arrays.toString(arg0.tones));
			if (arg0.tones.length == 0)// not found
			{
				if (arg1.tones.length == 0)
				{// not found in both
					// do nothing; continue next comparison
				}
				else
				{// found in 2nd
					return -1;//1st is earlier
				}
			}
			else
			{// found in 1
				if (arg1.tones.length == 0)
				{// not found in 2nd
					return +1;//1st is later
				}
				else
				{// found in both
					int result = compareTones(arg0.tones, 0, arg0.tones.length, arg1.tones, 0, arg1.tones.length);
//:					System.out.println(result);
					if (result != 0)
						return result;
//:					System.out.println(Letter.toHexString(Arrays.copyOfRange(arg0.letters, startIndex0, endIndex0)));
//:					System.out.println(Letter.toHexString(Arrays.copyOfRange(arg1.letters, startIndex1, endIndex1)));
				}
			}
			//end:compare "T"

			// Comparison result ("0") for "Tones" shows they are equal.
			// But separate variable is reserved for the result of "Vowels" comparison
			// in case that "-ံ" occurs in the vowels ,i.e.
			// Comparison between "-ု" and "-ံု" vowels
			// see <code>compareVowels()</code> method for more detail
			return r;
		}
	}

	/**
	 * This is an unsupervised version of 'Syllable comparator'.
	 * The content may not sync with changes in other areas of the project.
	 * Use at your own risks.
	 * Generally use in debugging of <code>SyllableHead</code> and 
	 * <code>SyllableTail</code> classes.
	 * The comparator scans code points itself without using any pre-generated
	 * code point maps, so it may result in bad performace of sorting large data.
	 *
	 * @author Min Thant Htoo
	 *
	 */
	public static class SyllableAbstrComparator implements Comparator<SyllableAbstr>
	{
		@Override
		public int compare(SyllableAbstr arg0, SyllableAbstr arg1)
		{
			boolean e = Arrays.equals(arg0.letters, arg1.letters);
			if (e)
				return 0;

//:			System.out.println(arg0 + " vs " + arg1);

			//compare consonants:"C"
			if (//arg0 instanceof SyllableHead && arg1 instanceof SyllableHead &&
				arg0.letters[0].codePoint != arg1.letters[0].codePoint)
				return (arg0.letters[0].codePoint - arg1.letters[0].codePoint);

//:			System.out.println("M");
			int startIndex0=-1,endIndex0=-1,startIndex1=-1,endIndex1=-1;
			//start:compare medials:"M"
			// find start medial of first arg
			for (int i = 1; i < arg0.letters.length; i++)
				if (arg0.letters[i].letterType == Letter.LETTER_TYPE_MEDIAL)
				{
					startIndex0 = i;
					break;
				}
			// find end medial of first arg
			if (startIndex0 > -1)
			{
				for (endIndex0 = startIndex0 + 1; endIndex0 < arg0.letters.length; endIndex0++)
					if (arg0.letters[endIndex0].letterType != Letter.LETTER_TYPE_MEDIAL)
						break;

			}
			// find start medial of second arg
			for (int i = 1; i < arg1.letters.length; i++)
				if (arg1.letters[i].letterType == Letter.LETTER_TYPE_MEDIAL)
				{
					startIndex1 = i;
					break;
				}
			// find end medial of second arg
			if (startIndex1 > -1)
			{
				for (endIndex1 = startIndex1 + 1; endIndex1 < arg1.letters.length; endIndex1++)
					if (arg1.letters[endIndex1].letterType != Letter.LETTER_TYPE_MEDIAL)
						break;
			}
			if (startIndex0 < 0)// not found
			{
				if (startIndex1 < 0)
				{// not found in both
					// do nothing; continue next comparison
				}
				else
				{// found in 2nd
					return -1;//1st is earlier
				}
			}
			else
			{// found in 1
				if (startIndex1 < 0)
				{// not found in 2nd
					return +1;//1st is later
				}
				else
				{// found in both
					//TODO:compare
					int r=compareMedials(arg0.letters, startIndex0, endIndex0, arg1.letters, startIndex1, endIndex1);
//:					System.out.println(r);
					if (r != 0)
						return r;
//:					System.out.println(Letter.toHexString(Arrays.copyOfRange(arg0.letters, startIndex0, endIndex0)));
//:					System.out.println(Letter.toHexString(Arrays.copyOfRange(arg1.letters, startIndex1, endIndex1)));
				}
			}
			//end:compare "M"

			// reuse the variables
//			startIndex0 = -1;endIndex0 = -1;startIndex1 = -1;endIndex1 = -1;
			//start: compare Finals:"F"
//:			System.out.println("F");
			// We assume "F" must be composed of one "C"/"V" letter and one "Asat"/"Virama" letter
			// find start final of first arg
			for (int i = 1; i < arg0.letters.length; i++)
				if (arg0.letters[i].letterType == Letter.LETTER_TYPE_FINAL &&
					(arg0.letters[i - 1].letterType == Letter.LETTER_TYPE_CONSONANT ||
					arg0.letters[i - 1].letterType == Letter.LETTER_TYPE_VOWEL_INDEPENDANT))
				{
					startIndex0 = i - 1;
					break;
				}
			// find end final of first arg
			if (startIndex0 > -1)
			{
				for (endIndex0 = startIndex0 + 1 ; endIndex0 < arg0.letters.length; endIndex0++)
					if (arg0.letters[endIndex0].letterType != Letter.LETTER_TYPE_FINAL)
						break;
			}
			// find start final of second arg
			for (int i = 1; i < arg1.letters.length; i++)
				if (arg1.letters[i].letterType == Letter.LETTER_TYPE_FINAL &&
					(arg1.letters[i - 1].letterType == Letter.LETTER_TYPE_CONSONANT ||
					arg1.letters[i - 1].letterType == Letter.LETTER_TYPE_VOWEL_INDEPENDANT))
				{
					startIndex1 = i - 1;
					break;
				}
			// find end final of second arg
			if (startIndex1 > -1)
			{
				for (endIndex1 = startIndex1 + 1; endIndex1 < arg1.letters.length; endIndex1++)
					if (arg1.letters[endIndex1].letterType != Letter.LETTER_TYPE_FINAL)
						break;
			}
			if (startIndex0 < 0)// not found
			{
				if (startIndex1 < 0)
				{// not found in both
					// do nothing; continue next comparison
				}
				else
				{// found in 2nd
					return -1;//1st is earlier
				}
			}
			else
			{// found in 1
				if (startIndex1 < 0)
				{// not found in 2nd
					return +1;//1st is later
				}
				else
				{// found in both
					int r=compareFinals(arg0.letters, startIndex0, endIndex0, arg1.letters, startIndex1, endIndex1);
//:					System.out.println(r);
					if (r != 0)
						return r;
//					System.out.println(Letter.toHexString(Arrays.copyOfRange(arg0.letters, startIndex0, endIndex0)));
//					System.out.println(Letter.toHexString(Arrays.copyOfRange(arg1.letters, startIndex1, endIndex1)));
				}
			}
			//end:compare "F"

			// reuse the variables
			startIndex0 = -1;endIndex0 = -1;startIndex1 = -1;endIndex1 = -1;
			//start: compare vowel:"v"
//:			System.out.println("V");
			// find start vowel of first arg
			for (int i = 1; i < arg0.letters.length; i++)
				if (arg0.letters[i].letterType == Letter.LETTER_TYPE_VOWEL_DEPENDANT)
				{
					startIndex0 = i;
					break;
				}
			// find end vowel of first arg
			if (startIndex0 > -1)
			{
				for (endIndex0 = startIndex0 + 1; endIndex0 < arg0.letters.length; endIndex0++)
					if (arg0.letters[endIndex0].letterType != Letter.LETTER_TYPE_VOWEL_DEPENDANT)
						break;
			}
			// find start vowel of second arg
			for (int i = 1; i < arg1.letters.length; i++)
				if (arg1.letters[i].letterType == Letter.LETTER_TYPE_VOWEL_DEPENDANT)
				{
					startIndex1 = i;
					break;
				}
			// find end vowel of second arg
			if (startIndex1 > -1)
			{
				for (endIndex1 = startIndex1; endIndex1 < arg1.letters.length; endIndex1++)
					if (arg1.letters[endIndex1].letterType != Letter.LETTER_TYPE_VOWEL_DEPENDANT)
						break;
			}
			if (startIndex0 < 0)// not found
			{
				if (startIndex1 < 0)
				{// not found in both
					// do nothing; continue next comparison
				}
				else
				{// found in 2nd
					return -1;//1st is earlier
				}
			}
			else
			{// found in 1
				if (startIndex1 < 0)
				{// not found in 2nd
					return +1;//1st is later
				}
				else
				{// found in both
					int r=compareVowels(arg0.letters, startIndex0, endIndex0, arg1.letters, startIndex1, endIndex1);
//:					System.out.println(r);
					if (r != 0)
						return r;

//:					System.out.println(Letter.toHexString(Arrays.copyOfRange(arg0.letters, startIndex0, endIndex0)));
//:					System.out.println(Letter.toHexString(Arrays.copyOfRange(arg1.letters, startIndex1, endIndex1)));
				}
			}
			//end:compare "v"


			// reuse the variables
			startIndex0 = -1;endIndex0 = -1;startIndex1 = -1;endIndex1 = -1;
			//start: compare Tones:"T"
//:			System.out.println("T");
			// find start tone of first arg
			for (int i = 1; i < arg0.letters.length; i++)
				if (arg0.letters[i].letterType == Letter.LETTER_TYPE_TONE)
				{
					startIndex0 = i;
					break;
				}
			// find end tone of first arg
			if (startIndex0 > -1)
			{
				for (endIndex0 = startIndex0 + 1; endIndex0 < arg0.letters.length; endIndex0++)
					if (arg0.letters[endIndex0].letterType != Letter.LETTER_TYPE_TONE)
						break;
			}
			// find start tone of second arg
			for (int i = 1; i < arg1.letters.length; i++)
				if (arg1.letters[i].letterType == Letter.LETTER_TYPE_TONE)
				{
					startIndex1 = i;
					break;
				}
			// find end tone of second arg
			if (startIndex1 > -1)
			{
				for (endIndex1 = startIndex1 + 1; endIndex1 < arg1.letters.length; endIndex1++)
					if (arg1.letters[endIndex1].letterType != Letter.LETTER_TYPE_TONE)
						break;
			}
			if (startIndex0 < 0)// not found
			{
				if (startIndex1 < 0)
				{// not found in both
					// do nothing; continue next comparison
				}
				else
				{// found in 2nd
					return -1;//1st is earlier
				}
			}
			else
			{// found in 1
				if (startIndex1 < 0)
				{// not found in 2nd
					return +1;//1st is later
				}
				else
				{// found in both
					int r=compareTones(arg0.letters, startIndex0, endIndex0, arg1.letters, startIndex1, endIndex1);
//:					System.out.println(r);
					if (r != 0)
						return r;
//:					System.out.println(Letter.toHexString(Arrays.copyOfRange(arg0.letters, startIndex0, endIndex0)));
//:					System.out.println(Letter.toHexString(Arrays.copyOfRange(arg1.letters, startIndex1, endIndex1)));
				}
			}
			//end:compare "T"

			int i;
			for (i = 0; i < arg0.letters.length; i++)
			{
				if (i >= arg1.letters.length)
					return 1;// 1st arg has longer length; then goes below
				if (arg0.letters[i].codePoint != arg1.letters[i].codePoint)
					return arg0.letters[i].codePoint
						- arg1.letters[i].codePoint;
			}
			if (i <= arg1.letters.length)
				return -1;
			return 0;
		}
	}

	private static final int compareMedials(Letter[] arg0, int start0, int end0, Letter[] arg1, int start1, int end1)
	{
		int l0=end0 - start0;
		int l1=end1 - start1;
		if (l0 != l1)
			return l0 - l1;
		else
		{
			for (int i = 0; i < arg0.length; i++)
			{
				if (i >= arg1.length)
					return 1;// 1st arg has longer length; then goes below
				if (arg0[i].codePoint != arg1[i].codePoint)
					return arg0[i].codePoint
						- arg1[i].codePoint;
			}
			return arg0[start0].codePoint - arg1[start1].codePoint;
		}

	}
	private static final int compareFinals(Letter[] arg0, int start0, int end0, Letter[] arg1, int start1, int end1)
	{
		int l0=end0 - start0;
		int l1=end1 - start1;
		if (l0 != l1)
			return l0 - l1;
		else
			return arg0[start0].codePoint - arg1[start1].codePoint;

	}

	public static final char[][] tones={
		{'\u1037'},{'\u1038'},{'\u1037','\u1038'}
	};

	private static final int compareVowels(Letter[] arg0, int start0, int end0, Letter[] arg1, int start1, int end1)
	{
		int l0=end0 - start0;
		int l1=end1 - start1;
		if (l0 == 0)
		{
			if (l1 == 0)
				return 0;
			else
				return -1;//1st is earlier
		}
		else if (l1 == 0)
		{
			return 1;//1st is later
		}

		if (l0 == l1)
		{
			if (l0 == 2)// both lengths == 2
				if (arg0[start0].codePoint == arg1[start1].codePoint && arg0[start0 + 1].codePoint == arg1[start1 + 1].codePoint)
					return 0;// both same
				else if (arg1[start1].codePoint == '\u102d' && arg1[start1 + 1].codePoint == '\u102f')
					return -1;//1st is earlier
				else
					return 1;//1st is later
			else//other lengths:1,3
				return arg0[start0].codePoint - arg1[start1].codePoint;
		}
		else if (l0 == 1)
		{
			if (l1 == 2)
			{
				if (arg0[start0].codePoint == '\u1036')
				{
					if (arg1[start1].codePoint == '\u102d' && arg1[start1 + 1].codePoint == '\u102f')
						return -1;//1st is earlier
					else
						return 1;//1st is later
				}
				// Comparison between "-ု" and "-ံု"
				// NOTE: Syllables containing the letters "-ံု" are the results of
				// programmatical fix for sorting of words,containing "-ံ" and
				// those containing "-မ်".
				// We have to add the "Final" letters("-မ်") to the words,
				// containing both "-ံ" and "-ု" because these words come after the words
				// containing "-မ်".
				// see <code>Letter.getSyllables()</code> for more detail
				else if (arg0[start0].codePoint == Letter.MM_VOWEL_SIGN_U &&
						 arg1[start1].codePoint == Letter.MM_SIGN_ANUSVARA &&
						 arg1[start1 + 1].codePoint == Letter.MM_VOWEL_SIGN_U)
					return Integer.MIN_VALUE;// "-ု" goes before "-ံု"
				else
				{
					return -1;//1st is earlier
				}
			}
			else
			{//if(l1==3){
				return 1;// 1st is later
			}
		}
		else if (l0 == 2)
		{
			if (l1 == 1)
			{
				if (arg1[start1].codePoint == '\u1036')
				{
					if (arg0[start0].codePoint == '\u102d' && arg0[start0 + 1].codePoint == '\u102f')
						return 1;//2nd is earlier
					else
						return -1;//2nd is later
				}
				// Comparison between "-ု" and "-ံု"
				else if (arg1[start1].codePoint == Letter.MM_VOWEL_SIGN_U &&
						 arg0[start0].codePoint == Letter.MM_SIGN_ANUSVARA &&
						 arg0[start0 + 1].codePoint == Letter.MM_VOWEL_SIGN_U)
					return Integer.MAX_VALUE;// "-ံု" goes after "-ု"
				else
				{
					return 1;//2nd is earlier
				}
			}
			else
			{//if(l1==3){
				return 1;// 1st is later
			}
		}
		else
		{//if(l0==3){
			if (l1 == 1)
			{
				if (arg1[start1].codePoint == '\u1036')
				{
					return -1;//1st is earlier
				}
				else
				{
					return 1;//1st is later
				}
			}
			else
			{//if(l1==2){
				if (arg1[start1].codePoint == '\u102d' && arg1[start1 + 1].codePoint == '\u102f')
					return -1;//1st is earlier
				else
					return 1;// 1st is later
			}
		}
	}
	private static final int compareTones(Letter[] arg0, int start0, int end0, Letter[] arg1, int start1, int end1)
	{
		int l0=end0 - start0;
		int l1=end1 - start1;
		if (l0 != l1)
			return l0 - l1;
		else
			return arg0[start0].codePoint - arg1[start1].codePoint;

	}
	public static class LetterComparator implements Comparator<Letter>
	{
		@Override
		public int compare(Letter arg0, Letter arg1)
		{
			if (arg0.codePoint != arg1.codePoint)
				return arg0.codePoint - arg1.codePoint;

			return 0;
		}
	}
}